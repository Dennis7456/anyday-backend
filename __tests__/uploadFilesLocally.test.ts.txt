import Fastify from 'fastify';
import multipart from '@fastify/multipart';
import { registerUploadFilesRoute } from '../src/routes/uploadFilesRoute'; // Import the route
import fs from 'fs'; 
// import fsPromises from 'fs/promises';
import { promises as fsPromises } from 'fs';
import path from 'path';
// import { Storage } from '@google-cloud/storage';
import { Readable } from 'stream';
import supertest from 'supertest';

// Mock dependencies
jest.mock('fs');
jest.mock('@google-cloud/storage');

describe('Upload Files Route', () => {
  const server = Fastify();

  beforeAll(() => {
    server.register(multipart, { 
        limits: {
             fileSize: 50 * 1024 * 1024,
            },
         });
         
    registerUploadFilesRoute(server); // Register the route
  });

  // Helper function to convert stream to buffer
const streamToBuffer = (stream: Readable): Promise<Buffer> => {
    return new Promise((resolve, reject) => {
      const chunks: Buffer[] = [];
      stream.on('data', chunk => chunks.push(chunk));
      stream.on('end', () => resolve(Buffer.concat(chunks)));
      stream.on('error', reject);
    });
  };

  it('should upload a file locally in development', async () => {
    process.env.NODE_ENV = 'development'; // Simulate the development environment

    // Mock file input
    const fileStream = new Readable();
    fileStream.push('file content');
    fileStream.push(null); // End of file

    const file = {
      filename: 'test-file.txt',
      mimetype: 'text/plain',
      file: fileStream,
    };

    // Create a temporary file to save the file content
    const tempFilePath = path.join(__dirname, 'test-file.txt');
    const writeStream = fs.createWriteStream(tempFilePath); // Use fs for streams

    // Pipe the fileStream into the writeStream to create the file
    fileStream.pipe(writeStream);

    // Wait for the file to be written
    await new Promise((resolve, reject) => {
      writeStream.on('finish', resolve);
      writeStream.on('error', reject);
    });

    // Simulate file upload using supertest
    const response = await supertest(server.server)
      .post('/api/upload/files')
      .attach('file', tempFilePath);

    // Clean up the temporary file after the test
    await fsPromises.unlink(tempFilePath); // Use fs/promises for unlinking

    expect(response.status).toBe(200);
    expect(response.body.uploadedFiles).toHaveLength(1);
    expect(response.body.uploadedFiles[0]).toHaveProperty('name', 'test-file.txt');
    expect(response.body.uploadedFiles[0]).toHaveProperty('url', '/uploads/test-file.txt');
  });

  it('should upload a file to Google Cloud Storage in production', async () => {
    process.env.NODE_ENV = 'production'; // Simulate the production environment
  
    // Create a file stream (Readable stream)
    const fileStream = new Readable();
    fileStream.push('file content');
    fileStream.push(null); // End of file
  
    const file = {
      filename: 'test-file.txt',
      mimetype: 'text/plain',
      file: fileStream,
    };
  
    // Convert the file stream to a buffer
    const fileBuffer = await streamToBuffer(fileStream);
  
    // Simulate file upload using supertest by attaching the buffer
    const response = await supertest(server.server)
      .post('/api/upload/files')
      .attach('file', fileBuffer, file.filename); // Attach the buffer and filename
  
    // Test assertions
    expect(response.status).toBe(200);
    expect(response.body.uploadedFiles).toHaveLength(1);
    expect(response.body.uploadedFiles[0]).toHaveProperty('url');
    expect(response.body.uploadedFiles[0]).toHaveProperty('size', '1234');
  });

  it('should return an error if no files are uploaded', async () => {
    const response = await supertest(server.server).post('/api/upload/files');
  
    expect(response.status).toBe(400);
    expect(response.text).toBe('No files uploaded.');
  });
  
  it('should reject files that exceed the size limit', async () => {
    const largeFile = {
      filename: 'large-file.txt',
      mimetype: 'text/plain',
      file: new Readable(),
    };
  
    // Simulate a large file stream
    largeFile.file.push('a'.repeat(60 * 1024 * 1024)); // 60MB file content
    largeFile.file.push(null);

    // Convert the file stream to a buffer
  const fileBuffer = await streamToBuffer(largeFile.file);

  // Simulate file upload using supertest by attaching the buffer
  const response = await supertest(server.server)
    .post('/api/upload/files')
    .attach('file', fileBuffer, largeFile.filename); // Attach the buffer and filename

  expect(response.status).toBe(400); // Assuming Fastify throws this error on large files
  expect(response.text).toContain('File too large');
  });
  
  
});
